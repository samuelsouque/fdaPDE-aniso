% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/test.R
\name{test}
\alias{test}
\title{aniso.smooth.FEM.PDE.basis}
\usage{
test()
}
\arguments{
\item{locations}{A matrix where each line contains the 2D coordinates of the observations}

\item{observations}{A vector of length \code{dim(FEMbasis$mesh$nodes)[1]} containing all observations, then \code{NA} until the required length is reached}

\item{FEMbasis}{An FEM basis oject}

\item{lambda}{a vector of regularization coefficients used for the estimation of K}

\item{PDE_parameters}{A list of parameters for the regularizing PDE. Contains K, b and c}

\item{covariates}{not implemented}

\item{BC}{not implemented}
}
\value{
a list containing the fit, the misfit and the estimated anisotropy matrix Kappa
}
\description{
Spatial regression with differential regularization: The anisotropy matrix is estimated from data. This function is a wrapper for a C++ execution of the algorithm.
}
\examples{

data("MeuseData")
data("MeuseBorder")

# Choose which variable we wish to predict
zinc <- MeuseData$zinc
# Create a mesh from the data
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = 1)
plot(mesh)
# Refine the mesh specifying the maximum area
mesh <- refine.MESH.2D(mesh, maximum_area=6000, delaunay=TRUE)
plot(mesh)
# Create the FEM basis object
FEM_basis <- create.FEM.basis(mesh)
# Choose a set of regularization coefficients
lambda = 10^seq(1,9,3)
# Define the regularization PDE parameters
kappa <- matrix(0, 2, 2) # Initial value of K
PDE_parameters <- list(K = kappa, b = c(0, 0), c = 0)
# SOLVE
smoothing_aniso <- aniso.smooth.FEM.PDE.basis(observations = c(zinc,rep(NA,dim(mesh$nodes)[1]-length(zinc))),FEMbasis = FEM_basis, lambda = lambda, PDE_parameters = PDE_parameters)
# Plot the result
plot(smoothing_aniso$fit.FEM)
# display the anisotropy numerically and graphically
anisotropyMatrix <- function(angle, intensity){
  Q <- matrix(c(cos(angle),-sin(angle),sin(angle),cos(angle)), byrow = TRUE, ncol = 2, nrow = 2)
  Sigma <- matrix(c(1,0,0,intensity), byrow = TRUE, nrow = 2, ncol = 2)/sqrt(intensity)
  return(Q\%*\%Sigma\%*\%solve(Q))
}
smoothing_aniso$anisotrpy
anisotropyMatrix(smoothing_aniso$anisotrpy[1],smoothing_aniso$anisotropy[2])
plot(mesh)
# The ellipse is a graphical representation of the estimated anisotropy
library(car)
ellipse(c(mean(MeuseData$x),mean(MeuseData$y)), shape = anisotropyMatrix(smoothing_aniso$anisotropy[1],smoothing_aniso$anisotropy[2]), radius=200, center.pch = 20, col = "blue", center.cex = 1, lwd = 2, lty = 1)




}
